\documentclass[11pt]{article}

\usepackage{fancyhdr}
\usepackage{geometry}
\usepackage[numbers]{natbib}

\renewcommand{\bibsection}{\begin{center}\textbf{\refname}\end{center}}

\lhead{CS 7400 -- Principles of Programming Languages \\
  Project Proposal, due October 23, 2012}
\rhead{Phillip Mates, Erik Silkensen \\
  \texttt{\{mates,ejs\}@ccs.neu.edu}}

\begin{document}

\thispagestyle{fancy}

% (1) Summarize your current understanding of the paper.
Compilers for higher-order languages often transform programs into
continuation-passing style (CPS) as an intermediate representation. In the
language of CPS terms, all procedures take a continuation argument $k$
that represents the ``rest of the computation;'' procedures apply $k$ to their
return value instead of returning directly. This form is beneficial to
compilers because it enables optimizations by way of simple $\beta$- and
$\eta$-reductions, and it simplifies code generation by resembling a low-level
target language. However, it comes at a cost: a na\"{\i}ve CPS transformation
greatly expands a program's size, which a realistic compiler must work to
reduce (and effectively invert).

\citet{Sabry:1992zr} studied the CPS transformation and discovered that a set
of so-called $A$-reductions applied directly to a source program would yield
a result equivalent  to that of translating into CPS, simplifying,
and inverting. \citet{Flanagan:1993fk} clarified this correspondence and
motivated the $A$-reductions by analyzing a sequence of abstract machines to
simulate compilation of a core Scheme-like language ($\mathit{CS}$), with and
without continuations. In particular, they consider the CEK machine for
$\mathit{CS}$, the CE and CEK machines for na\"{\i}ve and realistic
$\mathit{CPS}(\mathit{CS})$, and finally the CEK machine for $A(\mathit{CS})$.
They discuss the details of the machines and the translations between the
languages, prove the equivalence of the CEK machines for
$\mathit{CPS}(\mathit{CS})$ and $A(\mathit{CS})$, and conclude that compilers
using $A$-normal forms may enjoy the benefits of CPS-based compilers without
the overhead.

% (2) State which aspects of the paper you would like to understand in depth.
% (3) Explain which tools (Redex and otherwise) you wish to use to model the
% paper's insights so that you gain the desired insight.
%While we feel we understand the paper at a high level, we would like to
%understand the details of the abstract machines and transformations in more
%depth.  To that end, we plan to implement each machine in Redex and experiment
%hands-on with example programs (there aren't many in the paper) to get a better
%feel for how each machine operates, for how a program expands and reduces
%throughout the transformations, and so on.  On a first reading we weren't sure
%how the evaluation contexts in Figure 7 supported the reduction of
%$\mathit{CS}$ terms all the way to $A$-normal form, which we would like to work
%out.

% Paragraph about A-reductions vs beta-reductions
While introducing A-reductions on the source language, \citet{Flanagan:1993fk}
mention that the corresponding reduction on CPS terms is the
$\overline{\beta}$-reduction, which removes administrative $\lambda$'s from the
na\"{i}ve CPS translation.  In order to better understand the relation between
A and $\overline{\beta}$ reductions, we propose to model both reductions in
Redex.  Doing so is especially interesting since as they appear in Figure 7
\cite{Flanagan:1993fk}, the A-reduction and evaluation context are either
non-intuitive or in fact contain errors.

% Paragraph about errors in other figures
% TODO: finish this paragraph:
% Errors in Figure 3 and Figure 6.
To this end, we have identified two other small potential errors in the figures
of \cite{Flanagan:1993fk}. TODO: explain bugs found \ldots As a means to
resolve these suspicions, we propose to model the abstract machines (figures
2,4,5, and 8) and CPS transformations (figures 3 and 6) from
\cite{Flanagan:1993fk} in Redex.

% Paragraph about "Running Your Research"
% TODO: finish this paragraph:
In addition to finding errors, these models will allow for running the paper's
mathematics on concrete examples.
Doing so will enable us to solidify our understanding of how code shrinks and
grows through transformations, as well as, what redundancies introduced and
removed via language transformations and abstract machine formulations.

% \pagebreak

\bibliographystyle{abbrvnat}
% \nocite{*}
\bibliography{refs}

\end{document}
