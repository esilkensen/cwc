\documentclass[11pt]{article}

\usepackage{fancyhdr}
\usepackage{geometry}
\usepackage[numbers]{natbib}

\renewcommand{\bibsection}{\begin{center}\textbf{\refname}\end{center}}

\lhead{CS 7400 -- Principles of Programming Languages \\
  Project Proposal, due October 23, 2012}
\rhead{Phillip Mates, Erik Silkensen \\
  \texttt{\{mates,ejs\}@ccs.neu.edu}}

\begin{document}

\thispagestyle{fancy}

% (1) Summarize your current understanding of the paper.
Compilers for higher-order languages often transform programs into
continuation-passing style (CPS) as an intermediate representation. In the
language of CPS terms, all procedures take a continuation argument $k$
that represents the ``rest of the computation;'' procedures apply $k$ to their
return value instead of returning directly. This form is beneficial to
compilers because it enables optimizations by way of simple $\beta$- and
$\eta$-reductions, and it simplifies code generation by resembling a low-level
target language. However, it comes at a cost: a na\"{\i}ve CPS transformation
greatly expands a program's size, which a realistic compiler must work to
reduce (and effectively invert).

\citet{Sabry:1992zr} studied the CPS transformation and discovered that a set
of so-called $A$-reductions applied directly to a source program would yield
a result equivalent  to that of translating into CPS, simplifying,
and inverting. \citet{Flanagan:1993fk} clarified this correspondence and
motivated the $A$-reductions by analyzing a sequence of abstract machines to
simulate compilation of a core Scheme-like language ($\mathit{CS}$), with and
without continuations. In particular, they consider the CEK machine for
$\mathit{CS}$, the CE and CEK machines for na\"{\i}ve and realistic
$\mathit{CPS}(\mathit{CS})$, and finally the CEK machine for $A(\mathit{CS})$.
They discuss the details of the machines and the translations between the
languages, prove the equivalence of the CEK machines for
$\mathit{CPS}(\mathit{CS})$ and $A(\mathit{CS})$, and conclude that compilers
using $A$-normal forms may enjoy the benefits of CPS-based compilers without
the overhead.

% (2) State which aspects of the paper you would like to understand in depth.
% (3) Explain which tools (Redex and otherwise) you wish to use to model the
% paper's insights so that you gain the desired insight.
While we feel we understand the paper at a high level, we would like to
understand the details of the abstract machines and transformations in
more depth. To that end, we plan to implement each machine in Redex and
experiment hands-on with example programs (there aren't many in the paper)
to get a better feel for how each machine operates, for how a program
expands and reduces throughout the transformations, and so on. On a first
reading we weren't sure how the evaluation contexts in Figure 7 supported the
reduction of $\mathit{CS}$ terms all the way to $A$-normal form, which we
would like to work out.

%TODO: Should probably be more specific about details, about what we could try
%to understand; maybe should be more quick to details in the summary, too.

% \pagebreak

\bibliographystyle{abbrvnat}
% \nocite{*}
\bibliography{refs}

\end{document}
