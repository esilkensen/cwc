\documentclass[11pt]{article}

\usepackage{fancyhdr}
\usepackage{geometry}
\usepackage[numbers]{natbib}

\renewcommand{\bibsection}{\begin{center}\textbf{\refname}\end{center}}

\lhead{CS 7400 -- Principles of Programming Languages \\
  Project Proposal, due October 23, 2012}
\rhead{Phillip Mates, Erik Silkensen \\
  \texttt{\{mates,ejs\}@ccs.neu.edu}}

\begin{document}

\thispagestyle{fancy}

% (1) Summarize your current understanding of the paper.
Compilers for higher-order languages often transform programs into
continuation-passing style (CPS) as an intermediate representation. In the
language of CPS terms, all procedures take a continuation argument $k$
that represents the ``rest of the computation;'' procedures apply $k$ to their
return value instead of returning directly. This form is beneficial to
compilers because it enables optimizations by way of simple $\beta$- and
$\eta$-reductions, and it simplifies code generation by resembling a low-level
target language. However, it comes at a cost: a na\"{\i}ve CPS transformation
greatly expands a program's size, which a realistic compiler must work to
reduce (and effectively invert).

\citet{Sabry:1992zr} studied the CPS transformation and discovered that a set
of so-called $A$-reductions applied directly to a source program would yield
a result equivalent  to that of translating into CPS, simplifying,
and inverting. \citet{Flanagan:1993fk} clarified this correspondence and
motivated the $A$-reductions by analyzing a sequence of abstract machines for
a core Scheme-like language. An abstract machine simulates 

% (2) State which aspects of the paper you would like to understand in depth.
While

% (3) Explain which tools (Redex and otherwise) you wish to use to model the
% paper's insights so that you gain the desired insight.
We plan to

% \pagebreak

\bibliographystyle{abbrvnat}
% \nocite{*}
\bibliography{refs}

\end{document}
