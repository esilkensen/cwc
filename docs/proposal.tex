\documentclass{article}

\usepackage{alltt}
\usepackage{fancyhdr}
\usepackage{geometry}
\usepackage{stmaryrd}
\usepackage[numbers]{natbib}

\renewcommand{\bibsection}{\begin{center}\textbf{\refname}\end{center}}

\newcommand{\includeracket}[1]{
\pagebreak
\lhead{Appendix: Redex Model}
\rhead{\emph{File: #1.rkt}}
\pagestyle{fancy}
%\begin{small}
\input{appendix/#1}
%\end{small}
}

\lhead{CS 7400 -- Principles of Programming Languages \\
  Revised Project Memo, due November 19, 2012}
\rhead{Phillip Mates, Erik Silkensen \\
  \texttt{\{mates,ejs\}@ccs.neu.edu}}
\cfoot{}

\begin{document}

\thispagestyle{fancy}

% (1) Summarize your current understanding of the paper.
Compilers for higher-order languages often transform programs into
continuation-passing style (CPS) form as an intermediate representation. In the
language of CPS terms, all procedures take a continuation argument $k$
that represents the ``rest of the computation;'' procedures apply $k$ to their
return value instead of returning directly. This form is beneficial to
compilers because it enables optimizations by way of simple $\beta$- and
$\eta$-reductions, and it simplifies code generation by resembling a low-level
target language.
% TODO: rewrite following sentence with more examples(?)
However, it comes at a cost: a na\"{\i}ve CPS transformation greatly expands a
program's size, which a realistic compiler must work to reduce.

\citet{Sabry:1992zr} observed that the transformation typically involves three
phases: compilers translate into CPS, simplify the result, and then invert the
translation during code generation. They showed how a set of so-called
$A$-reductions applied directly to a source program yields a result equivalent
to the combined effect of the CPS transformation.
% TODO: make 'both' below less ambiguous
\citet{Flanagan:1993fk} clarified this correspondence by developing a sequence
of abstract machines simulating the compilation of a Scheme-like language using
both CPS and $A$-reduction strategies.  They discuss the details of the
machines and the translations between the languages, and prove the equivalence
of CEK machines specialized for CPS and $A$-normal form terms.  They conclude
that compilers using $A$-normal forms may enjoy the benefits of CPS-based
compilers without the overhead.

% (2) State which aspects of the paper you would like to understand in depth.
% (3) Explain which tools (Redex and otherwise) you wish to use to model the
% paper's insights so that you gain the desired insight.

% TODO: expand on subtleties of models
While we understand their reasoning at a high level, we would like to grasp
the subtleties of the abstract machines and language transformations.
Towards that end, we plan to implement each machine and transformation
in Redex. By running executable models of the paper's mathematics on concrete
examples, we will gain a better understanding of how programs change throughout
the transformations, how modifications to the machines remove redundancies, and
the reasons for why it may be advantageous for a compiler to use $A$-reductions
instead of CPS.

% TODO: talk about bugs and A-reduction redex model
As a side effect, we also think this project will help us discover to how a
tool such as Redex is useful to programming language researchers in the
real world. For example, as we began implementing a model of the paper,
we noticed what seem to be two typos in the na\"{i}ve and inverse CPS
transformations. We were also puzzled by the definition of evaluation contexts
for the $A$-reductions and plan to check our understanding by implementing a
working model in Redex.

\bibliographystyle{abbrvnat}
\bibliography{refs}

\includeracket{cs}
\includeracket{cs-cek}
\includeracket{cps}
\includeracket{cps-ce}
\includeracket{cps-cek}
\includeracket{a}
\includeracket{a-cek}

\end{document}
